共轭梯度法的原理

在寻找最优值的过程中当前点xk，出的梯度向量gk 和前一迭代点xk处的搜索方向dk−1对搜索方向进行如下修正：

            dk = -gk + beta_k-1 * d_k-1

其修正系数βk−1的取值有一个约束条件，即要确保dk与dk−1,dk−2,⋯,d0之间满足关于G的共轭关系。这就是共轭梯度法的基本思想。
修正系数βk−1的取值方法有多个，下面的例子采用的取值公式为:
                    gTkgk
            βk−1 = --------
                    gTk−1gk−1

可以看出共轭梯度法的搜索方向dk的计算只需要梯度向量，不需要矩阵G，可以推广到非二次目标函数的极小值求解，但是这种推广也
带来了构造的搜索向量序列{dk}不共轭的问题，后面有提到解决办法。


算法代码描述：

step 1: 给定迭代精度0≤ϵ≪1和初始点x0. 计算g0=∇f(x0). . 令k←0.

step 2: 若||gk||≤ϵ，停止迭代，输出x∗≈xk

step 3: 计算搜索方向 dk

            dk=  −gk                      k = 0
                 −gk+βk−1dk−1k=0k≥1       k >= 1

step 4:  利用线搜索方法确定搜索步长αk

step 5:  令 令xk+1←xk+αkdk，并计算gk+1=∇f(xk+1)

step 6:  k←k+1，转step 2


说明：

通常来说，共轭梯度法的收敛速度比最速下降法快，而且不用像牛顿法那样计算海森矩阵及其逆矩阵。
但是随着迭代次数的增加，新构造的共轭方向由于误差（如果目标函数不是二次函数则会造成这种误差）
积累会逐渐不精确甚至不下降，可能出现收敛速度极慢的现象。为了避免这种现象，一种有效的改进办法是：

   每迭代n次或者不下降时就再次插入负梯度方向作为搜索方向，从新开始共轭梯度算法。下面的代码就采用了这种思想。


