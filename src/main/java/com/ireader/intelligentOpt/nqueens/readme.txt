回溯法

回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，
发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某
个状态的点称为“回溯点”。

 基本思想
在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，
要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其
祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根
结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。

状态空间E表示成一棵高为n的带权有序树T，把在E中求问题P的所有解转化为在T中搜索问题P的所有解。

回溯法解题的一般步骤

（1）针对所给问题，定义问题的解空间；
（2）确定易于搜索的解空间结构；
（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

八皇后问题是能用回溯法解决的一个经典问题。
八皇后问题是一个古老而著名的问题。该问题是十九世纪著名的数学家高斯1850年提出：在8X8格的国际象棋上摆放八个皇后，
使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一对角线上，问有多少种摆法。引入一个整型一维数组col[]
来存放最终结果，col[i]就表示在棋盘第i列、col[i]行有一个皇后，为了使程序再找完了全部解后回到最初位置，设定col[0]
的初值为0，即当回溯到第0列时，说明以求得全部解，结束程序运行。为了方便算法的实现，引入三个整型数组来表示当前列在三
个方向上的状态 ：

a[] a[i]=0表示第i行上还没有皇后；
b[] b[i]=0表示第i列反斜线/上没有皇后；
c[] c[i]=0表示第i列正斜线\上没有皇后。

棋盘中同一反斜线/上的方格的行号与列号相同；同一正斜线\上的方格的行号与列号之差均相同，这就是判断斜线的依据。
初始时，所有行和斜线上都没有皇后，从第1列的第1行配置第一个皇后开始，在第m列，col[m]行放置了一个合理的皇后，
准备考察第m+1列时，在数组a[]，b[]和c[]中为第m列，col[m]行的位置设定有皇后的标志；当从第m列回溯到m-1列时，
并准备调整第m-1列的皇后配置时，清除在数组a[],b[]和c[]对应位置的值都为1来确定。



一般情况下0-1背包问题是NP难的。用回溯法求解：
  （1）定义问题的解空间：对于有n种可选物品的0-1背包问题，解是长度为n的0-1向量。因此解空间为所有的2**n个0-1向量。
      例如当n=3时，解空间为所有的8个0-1向量。
  （2）确定解空间树的结构：通常将解空间组织成树（或图）的形式。这里可将2**n个解向量组织成一棵完全二叉树，树枝上用
      1或0标记，从树根到树叶的任一路径表示解空间中的一个解。一般地，当所给问题是从n个元素（这里为n个物品）的集合S
      中找出满足某种性质的子集时，相应的解空间树称为子集树。0-1背包问题的解空间就是一棵子集树，这个子集树是完全二
      叉树，有2*n个叶结点，其结点总个数为2**(n+1)-1，遍历子集树的任何算法需要至少2**n的计算时间。
  （3）以深度优先方式搜索整个解空间树，找出所要的解：搜索从根结点开始（成为当前扩展结点），不断地向纵深方向移动到新
       结点，成为新的扩展结点。如果当前扩展结点不能再向纵深方向移动了，即再往前移动就会导致无效解或非最优解，则成为
       死结点。此时应回溯到最近一个活结点处，使其成为当前扩展结点，继续向另外一个方向移动。回溯法即以这种工作方式递
       归地在解空间中搜索，直到找到所要的解或解空间中已无活结点时为止。在搜索过程中通常可以用约束函数或限界函数（统
       称为剪枝函数）剪去导致无效解或非最优解的子树，以避免无效搜索，提高平均搜索效率。
       注意解空间树是在递归搜索过程中动态产生的，并不需要事先建立一个解空间树，然后再去搜索。对0-1背包问题，只要左儿
       子是一个可行结点，搜索就进入其左子树，右子树只在有可能包含最优解时才进入，否则剪去右子树。我们引入上界函数来判
       断当前扩展结点是否满足上界条件，即右子树是否有可能包含最优解，若不满足则进行剪枝。
  （4）回溯法的数据结构描述：包括解空间树的结点信息，用于构造最优解的数据成员、可选的剪枝函数，回溯函数Backtrack(i)，
       算法实现函数等。通常用一个类来描述，算法实现函数也可以一个独立的全局函数。


优化：

N皇后——最小冲突算法一个相对高效的实现： http://www.cnblogs.com/fstang/archive/2013/05/12/3073598.html

N皇后问题的两个最高效的算法 ： http://blog.csdn.net/hackbuteer1/article/details/6657109


